#include <ntddk.h>
#include <wdf.h>
#pragma warning(disable : 4201)
#include <fwpsk.h>
#include "WindscribeCallout.h"
#include "CalloutFunctions.h"

WDFDEVICE wdfDevice = NULL;
// Variable for the run-time callout identifier
UINT32 CalloutId = 0;

EVT_WDF_DRIVER_UNLOAD UnloadFunc;

NTSTATUS
DriverEntry(
	_In_ PDRIVER_OBJECT     DriverObject,
	_In_ PUNICODE_STRING    RegistryPath
)
{
	NTSTATUS status = STATUS_SUCCESS;
	WDF_DRIVER_CONFIG config;
	WDFDRIVER driver;
	PWDFDEVICE_INIT deviceInit;
	PDEVICE_OBJECT deviceObject = NULL;
	FWPS_CALLOUT1 callout = { 0 };

	// Initialize the driver configuration object
	WDF_DRIVER_CONFIG_INIT(&config, WDF_NO_EVENT_CALLBACK);

	config.DriverInitFlags |= WdfDriverInitNonPnpDriver;
	config.EvtDriverUnload = UnloadFunc;

	// Create the driver object
	status = WdfDriverCreate(DriverObject, RegistryPath, WDF_NO_OBJECT_ATTRIBUTES, &config,	&driver);

	if (status != STATUS_SUCCESS)
	{
		KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "WindscribeSplitTunnel: WdfDriverCreate failed\n"));
		return status;
	}

	// Allocate a device initialization structure
	deviceInit = WdfControlDeviceInitAllocate(driver, &SDDL_DEVOBJ_KERNEL_ONLY);
	if (deviceInit == NULL)
	{
		KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "WindscribeSplitTunnel: WdfControlDeviceInitAllocate failed\n"));
		return status;
	}

	// Set the device characteristics
	WdfDeviceInitSetCharacteristics(deviceInit, FILE_DEVICE_SECURE_OPEN, FALSE);
	WdfDeviceInitSetDeviceType(deviceInit, FILE_DEVICE_NETWORK);
	WdfDeviceInitSetCharacteristics(deviceInit, FILE_AUTOGENERATED_DEVICE_NAME, TRUE);

	// Create a framework device object
	status = WdfDeviceCreate(&deviceInit, WDF_NO_OBJECT_ATTRIBUTES, &wdfDevice);

	// Check status
	if (status == STATUS_SUCCESS) 
	{
		// Initialization of the framework device object is complete
		WdfControlFinishInitializing(wdfDevice);

		// Get the associated WDM device object
		deviceObject = WdfDeviceWdmGetDeviceObject(wdfDevice);
	}
	else
	{
		KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "WindscribeSplitTunnel: WdfDeviceCreate failed\n"));
		return status;
	}

	
	callout.calloutKey = WINDSCRIBE_CALLOUT_GUID;
	callout.classifyFn = ClassifyFn;
	callout.notifyFn = NotifyFn;

	status = FwpsCalloutRegister1(deviceObject, &callout, &CalloutId);

	if (status != STATUS_SUCCESS) 
	{
		KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "WindscribeSplitTunnel: FwpsCalloutRegister1 failed\n"));
	}
	else
	{
		KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "WindscribeSplitTunnel: DriverEntry successfully\n"));
	}

	return status;
}

VOID UnloadFunc(_In_ WDFDRIVER Driver)
{
	UNREFERENCED_PARAMETER(Driver);
	NTSTATUS status = STATUS_SUCCESS;

	// Unregister the callout
	status = FwpsCalloutUnregisterById0(CalloutId);

	if (status != STATUS_SUCCESS)
	{
		KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "WindscribeSplitTunnel: FwpsCalloutUnregisterById0 failed\n"));
	}

	// Delete the framework device object
	WdfObjectDelete(wdfDevice);

	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "WindscribeSplitTunnel: UnloadFunc finished successfully\n"));
}