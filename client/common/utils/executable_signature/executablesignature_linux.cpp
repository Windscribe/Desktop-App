#include "executablesignature_linux.h"

#include <codecvt>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <memory>
#include <sstream>
#include <openssl/decoder.h>
#include <openssl/evp.h>
#include <openssl/sha.h>

#include "executable_signature.h"
#include "../../../common/utils/openssl_utils.h"
#include "../../../common/utils/wsscopeguard.h"

// key_pub.txt is generated by build_all.py from key.pub
// The syntax used in key_pub.txt utilizes the raw string literals feature of the C++11 standard.
// - https://www.stroustrup.com/C++11FAQ.html#raw-strings
#ifdef USE_SIGNATURE_CHECK
const char* g_PublicKeyData =
#include "../../../common/keys/linux/key_pub.txt"
;
#else
// key_pub.txt won't be generated for non-signed builds
const char* g_PublicKeyData = "";
#endif


ExecutableSignaturePrivate::ExecutableSignaturePrivate(ExecutableSignature* const q) : ExecutableSignaturePrivateBase(q)
{
}

ExecutableSignaturePrivate::~ExecutableSignaturePrivate()
{
}

bool ExecutableSignaturePrivate::verify(const std::string& exePath)
{
    std::string pubKeyBytes(g_PublicKeyData);

    EVP_PKEY *pkey = NULL;
    EVP_MD_CTX *mdctx = NULL;
    OSSL_DECODER_CTX *dctx = NULL;
    FILE *datafile = NULL;
    FILE* sign = NULL;

    auto exitGuard = wsl::wsScopeGuard([&] {
        if (sign) {
            fclose(sign);
        }
        if (datafile) {
            fclose(datafile);
        }
        OSSL_DECODER_CTX_free(dctx);
        EVP_PKEY_free(pkey);
        EVP_MD_CTX_free(mdctx);
    });


    // key.pub is 800 bytes on disk
    if (pubKeyBytes.size() > 800) {
        lastError_ << "Invalid public key, size is too large: " << pubKeyBytes.size() << " bytes";
        return false;
    }

    // Read signature from file
    std::filesystem::path path(exePath);
    path = path.parent_path() / "signatures" / (path.filename().string() + ".sig");
    sign = fopen(path.c_str(), "r");

    if (sign == NULL) {
        lastError_ << "Failed to open signature file (" << path << ") for reading: " << errno;
        return false;
    }

    const size_t sigSize = 65536;
    std::unique_ptr<unsigned char[]> sigData(new unsigned char[sigSize]);
    size_t bytesRead = fread(sigData.get(), 1, sigSize, sign);

    // The RSA signature for the 4096-bit RSA key we use is 512 bytes.
    if (bytesRead != 512) {
        lastError_ << "Signature file is an invalid size, or failed to read entire file. Expected 512 bytes, read " << bytesRead << ".";
        return false;
    }

    // Calculate SHA256 digest for datafile
    datafile = fopen(exePath.c_str() , "rb");
    if (datafile == NULL) {
        lastError_ << "Failed to open executable for reading: " << errno;
        return false;
    }

    // Decode the RSA key
    dctx = OSSL_DECODER_CTX_new_for_pkey(&pkey, NULL, NULL, "RSA", OSSL_KEYMGMT_SELECT_PUBLIC_KEY | OSSL_KEYMGMT_SELECT_DOMAIN_PARAMETERS, NULL, NULL);

    if (dctx == NULL) {
        lastError_ << "Failed to find decoder for key";
        return false;
    }

    const unsigned char *data = (const unsigned char *)pubKeyBytes.c_str();
    size_t dataLen = pubKeyBytes.size();
    if (OSSL_DECODER_from_data(dctx, &data, &dataLen) != 1) {
        lastError_ << "Failed to read the RSA public key";
        return false;
    }

    // Verify the signature
    if((mdctx = EVP_MD_CTX_new()) == NULL || EVP_DigestVerifyInit(mdctx, NULL, EVP_sha256(), NULL, pkey) != 1) {
        lastError_ << "Failed to initialize EVP_MD_CTX";
        return false;
    }

    const size_t fileDataSize = 65536;
    std::unique_ptr<unsigned char[]> fileData(new unsigned char[fileDataSize]);

    while ((bytesRead = fread(fileData.get(), 1, fileDataSize, datafile))) {
        if (EVP_DigestVerifyUpdate(mdctx, fileData.get(), bytesRead) != 1) {
            lastError_ << "Failed to update digest";
            return false;
        }
    }

    if (EVP_DigestVerifyFinal(mdctx, sigData.get(), 512) != 1) {
        lastError_ << "Failed to verify signature";
        return false;
    }

    return true;
}

bool ExecutableSignaturePrivate::verify(const std::wstring& exePath)
{
    std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;
    std::string converted = converter.to_bytes(exePath);
    return verify(converted);
}
