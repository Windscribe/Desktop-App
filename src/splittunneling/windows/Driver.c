#include <ntddk.h>
#include <wdf.h>
#pragma warning(disable : 4201)
#include <fwpsk.h>
#include "WindscribeCallout.h"
#include "CalloutFunctions.h"

WDFDEVICE wdfDevice = NULL;
// Variable for the run-time callout identifier
UINT32 NonTcpCalloutId = 0;
UINT32 TcpCalloutId = 0;

EVT_WDF_DRIVER_UNLOAD UnloadFunc;

NTSTATUS
DriverEntry(
    _In_ PDRIVER_OBJECT     DriverObject,
    _In_ PUNICODE_STRING    RegistryPath
)
{
    NTSTATUS status = STATUS_SUCCESS;
    WDF_DRIVER_CONFIG config;
    WDFDRIVER driver;
    PWDFDEVICE_INIT deviceInit;
    PDEVICE_OBJECT deviceObject = NULL;
    FWPS_CALLOUT1 nonTcpCallout = { 0 };
    FWPS_CALLOUT1 tcpCallout = { 0 };

    // Initialize the driver configuration object
    WDF_DRIVER_CONFIG_INIT(&config, WDF_NO_EVENT_CALLBACK);

    config.DriverInitFlags |= WdfDriverInitNonPnpDriver;
    config.EvtDriverUnload = UnloadFunc;

    // Create the driver object
    status = WdfDriverCreate(DriverObject, RegistryPath, WDF_NO_OBJECT_ATTRIBUTES, &config,    &driver);

    if (status != STATUS_SUCCESS)
    {
        KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "WindscribeSplitTunnel: WdfDriverCreate failed\n"));
        return status;
    }

    // Allocate a device initialization structure
    deviceInit = WdfControlDeviceInitAllocate(driver, &SDDL_DEVOBJ_KERNEL_ONLY);
    if (deviceInit == NULL)
    {
        KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "WindscribeSplitTunnel: WdfControlDeviceInitAllocate failed\n"));
        return status;
    }

    // Set the device characteristics
    WdfDeviceInitSetCharacteristics(deviceInit, FILE_DEVICE_SECURE_OPEN, FALSE);
    WdfDeviceInitSetDeviceType(deviceInit, FILE_DEVICE_NETWORK);
    WdfDeviceInitSetCharacteristics(deviceInit, FILE_AUTOGENERATED_DEVICE_NAME, TRUE);

    // Create a framework device object
    status = WdfDeviceCreate(&deviceInit, WDF_NO_OBJECT_ATTRIBUTES, &wdfDevice);

    // Check status
    if (status == STATUS_SUCCESS)
    {
        // Initialization of the framework device object is complete
        WdfControlFinishInitializing(wdfDevice);

        // Get the associated WDM device object
        deviceObject = WdfDeviceWdmGetDeviceObject(wdfDevice);
    }
    else
    {
        KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "WindscribeSplitTunnel: WdfDeviceCreate failed\n"));
        return status;
    }

    nonTcpCallout.calloutKey = WINDSCRIBE_BIND_CALLOUT_GUID;
    nonTcpCallout.classifyFn = ClassifyFn;
    nonTcpCallout.notifyFn = NotifyFn;

    status = FwpsCalloutRegister1(deviceObject, &nonTcpCallout, &NonTcpCalloutId);
    if (status != STATUS_SUCCESS)
    {
        KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "WindscribeSplitTunnel: FwpsCalloutRegister1 (bind) failed\n"));
        return status;
    }

    tcpCallout.calloutKey = WINDSCRIBE_TCP_CALLOUT_GUID;
    tcpCallout.classifyFn = ClassifyFn;
    tcpCallout.notifyFn = NotifyFn;

    status = FwpsCalloutRegister1(deviceObject, &tcpCallout, &TcpCalloutId);
    if (status != STATUS_SUCCESS)
    {
        KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "WindscribeSplitTunnel: FwpsCalloutRegister1 (TCP) failed\n"));
        return status;
    }

    KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "WindscribeSplitTunnel: DriverEntry successfully\n"));
    return status;
}

VOID UnloadFunc(_In_ WDFDRIVER Driver)
{
    UNREFERENCED_PARAMETER(Driver);
    NTSTATUS status = STATUS_SUCCESS;

    // Unregister the callout
    status = FwpsCalloutUnregisterById0(NonTcpCalloutId);
    if (status != STATUS_SUCCESS)
    {
        KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "WindscribeSplitTunnel: FwpsCalloutUnregisterById0 failed\n"));
    }
    status = FwpsCalloutUnregisterById0(TcpCalloutId);
    if (status != STATUS_SUCCESS)
    {
        KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "WindscribeSplitTunnel: FwpsCalloutUnregisterById0 failed\n"));
    }

    // Delete the framework device object
    WdfObjectDelete(wdfDevice);

    KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "WindscribeSplitTunnel: UnloadFunc finished successfully\n"));
}